1. The schema for the car table: 

Djangocarlist database schema:

CREATE TABLE "carlistapp_car" 
	("id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
	"car_position" integer NOT NULL, 
	"car_name" varchar(100) NOT NULL, 
	"car_color" varchar(20) NOT NULL);

The id is autogenerated by django. I used 'car_position' instead of the 'id' to make it easier for django to automatically map foreign keys if a need arises. 'car_position' is an integer used to denote the current position of a specific car in a line. 'car_name' is a descriptive name (maximum of 100 characters) for a car in a certain position. It is not unique. Other cars may have the same 'car_name'. 'car_color' is the color of the car. It is set to a maximum of 20 characters.

The indexes used are:
car_position = to order the cars according to their position. It is also used to get the set of cars within the current_position and new_position
car_color = to get the set of cars based on color



2. Code for the move operation is executed in python and django:

		#gets the current position and the new position where the car will be placed
		cur_position = request.POST.get('current_position')
		n_position = request.POST.get('new_position')
		current_position = int(cur_position)
		new_position = int(n_position)
		form = CreateNewForm()

		#if current position is equal to new position, do nothing. go back to home page
		if(current_position == new_position):
			return redirect('/home/')

		#if new position exceeds total number of cars, notify user	
		elif (new_position > Car.objects.count()):
			return HttpResponse('New position is invalid')

		else:
			#if current position and new position are not equal
			car_for_positioning = get_object_or_404(Car, car_position = current_position)
		
			#if current_position is greater than new_position, move the cars from the new_position to the car before the current_position one space farther from the front.
			if (current_position > new_position):
				car_query_set = Car.objects.filter(car_position__lt=current_position, car_position__gte=new_position)
				if (current_position - new_position < 1000):
					for car in car_query_set:
						car.car_position = car.car_position + 1
						car.save()
				else:	
					for car in car_query_set.iterator():
						car.car_position = car.car_position + 1
						car.save()
			
			#if current_position is less than new_position, move the cars after the one in the current_position upto and including the car in the new_position one space nearer to the front.
			if (current_position < new_position):
				car_query_set = Car.objects.filter(car_position__lte=new_position, car_position__gt=current_position)

				if (new_position - current_position < 1000):
					for car in car_query_set:
						car.car_position = car.car_position - 1
						car.save()
				else:
					for car in car_query_set.iterator:
						car.car_position = car.car_position - 1
						car.save()

			#position the car in the new position		
			car_for_positioning.car_position = new_position
			car_for_positioning.save()

			#render to html
			color_values = Car.objects.values('car_color').order_by().distinct()
			context = {'form' : form, 'all_cars' : Car.objects.all().order_by('car_position'), 'color_values' : color_values}
			return render(request, 'carlistapp/home.html', context)


3. Car.objects.raw('SELECT * FROM carlist_app WHERE car_color = %s', [color])

4. If the difference between the current_position and the new_position is small, using the iterator is inefficient because it is better if it is cached in memory. However, if the difference between the two is huge, iterator is better because it does not perform caching.